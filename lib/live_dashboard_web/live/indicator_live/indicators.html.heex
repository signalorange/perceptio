<div class="container mx-auto">
  <div class="grid grid-cols-3 gap-4 mb-4">
    <!-- Chart 1 -->
    <div class="bg-white shadow-md rounded-lg p-3 col-span-1">
      <h2 class="text-xl font-semibold mb-4">Lignes de commandes <b><span style="color:rgba(149, 97, 226, 1)">aujourd'hui</span></b></h2>
      <div class="chart-container text-justify mx-auto ml-8">
        <span class="
                                    inline-block 
                                    text-black-500  
                                    py-1  
                                    rounded-full 
                                    text-5xl
                                    leading-tight
                                    text-left">
          <span>Total: <span id="comm_today" >0</span></span>
          <br/>
          <span class="border-b-4 pb-2">Livrées: (<span id="comm_livrees" style="color:rgba(76, 175, 80, 1)">0</span>)</span>
          
          <span>Restantes: <span id="comm_restant" style="color:rgba(149, 97, 226, 1)">0</span></span>
        </span>

      </div>
    </div>
    <div class="bg-white shadow-md rounded-lg p-3 col-span-2 pl-4">
    <h2 class="text-xl font-semibold mb-4">Tendance horaire <b><span style="color:#607d8b">7 jours</span></b> vs <b><span style="color:rgba(149, 97, 226, 1)">aujourd'hui</span></b></h2>
      <div class="chart-container">
        <canvas id="trend-chart" width="1000" height="250"></canvas>
        <!--<progress value="45" max="100" class="w-full">15%</progress>-->
      </div>    
    </div>
  </div>
  <div class="grid grid-cols-3 gap-4 mb-4">
    <!-- Chart 1 -->
    <div class="bg-white shadow-md rounded-lg p-3 col-span-1 pl-4">
    <h2 class="text-xl font-semibold mb-4">État des <b>lignes</b> de commandes</h2>
      <div class="chart-container">
        <canvas id="pie-chart" width="500" height="400"></canvas>
        <!--<progress value="45" max="100" class="w-full">15%</progress>-->
      </div>    
    </div>
    <!-- Chart 2 -->
    <div class="bg-white shadow-md rounded-lg p-3 col-span-1">
      <h2 class="text-xl font-semibold mb-4">Lignes de commandes par <b>Catégorie de produit</b></h2>
      <div class="chart-container">
        <canvas id="cable-chart" width="500" height="400"></canvas>
      </div>
    </div>
    <!-- Chart 5 -->
    <div class="bg-white shadow-md rounded-lg p-3 col-span-1 pr-4">
      <h2 class="text-xl font-semibold mb-4">Lignes de commandes par <b>Catégorie de route</b></h2>
      <div class="chart-container">
        <canvas id="route-chart" width="500" height="400"></canvas>
      </div>
    </div>
  </div>
  
</div>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    const rouge = 'rgba(232, 0, 0, 1)'
    const orange = 'rgba(255, 143, 0, 1)'
    const bleu = 'rgba(24, 134, 224, 1)'
    const vert = 'rgba(76, 175, 80, 1)'
    const mauve = 'rgba(149, 97, 226, 1)'
    const ctx = document.getElementById('pie-chart').getContext('2d');
    const chart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: [ 'Livrées', 'Restantes', 'Pickées', 'Imprimées', 'À faire'],
        datasets: [{
          label: 'Lignes',
          data: [ 0, 0, 0, 0, 0],
          backgroundColor: [
            vert,
            mauve,
            bleu, 
            //'rgba(255, 205, 86, 0.75)', 
            orange, 
            rouge],
          borderColor: '#ffffff',
          borderWidth: 2
        }]
      },
      options: {
        responsive: true,
        scales: {
          r: {
            pointLabels: {
              display: true,
              centerPointLabels: true,
              font: {
                size: 18
              }
            }
          },
          y: {
            stacked: true,
            beginAtZero: true,
            title: {
              display: true,
              text: 'Lignes de commandes',
              font: {
                weight: 'bold',
              },
            },
             ticks: {
                // forces step size to be 50 units
                stepSize: 10
                },
                max: 200
            //type: 'logarithmic',
          },
          x:{
            display: true,
            title: {
              display: true,
              text: 'Statut',
              font: {
                weight: 'bold',
              },
            }
          }
        },
        plugins: {
          legend: {
            display: false,
            position: 'bottom'
          }
        }
      }
    });
    // Stacked chart for Lignes de câbles
  const cableCtx = document.getElementById('cable-chart').getContext('2d');
  const types = new Chart(cableCtx, {
    type: 'bar',
    data: {
      labels: ['Produits en tablette', 'Produits câbles', 'Produits extérieurs'],
      datasets: [
        {
          label: 'Pickées',
          data: [0, 0, 0],
          backgroundColor: bleu,
          //stack: 'Pickées',
          borderWidth: 1,
          borderColor: 'white',
          borderWidth: {
            top: 1,
          }
        },
        {
          label: 'Imprimées',
          data: [0, 0, 0],
          backgroundColor: orange,
          //stack: 'Imprimées',
          borderWidth: 1,
          borderColor: 'white',
          borderWidth: {
            top: 1,
          }
        },
        {
          label: 'À faire',
          data: [0, 0, 0],
          backgroundColor: rouge,
          //stack: 'À faire',
        }
      ]
    },
    options: {
      responsive: true,
      scales: {
        x: {
          stacked: true,
          display: true,
          title: {
            display: true,
            text: 'Catégorie de produit',
            font: {
                weight: 'bold',
              },
          }
        },
        y: {
          stacked: true,
          beginAtZero: true,
          title: {
            display: true,
            text: 'Lignes de commandes',
            font: {
                weight: 'bold',
              },
          },
             ticks: {
                // forces step size to be 50 units
                stepSize: 10
                },
                max: 200
          //type: 'logarithmic',
        }
      },
      plugins: {
        legend: {
            display: true,
            position: 'bottom'
          }
      }
    }
  });
    // Stacked chart for routes
  const routeCtx = document.getElementById('route-chart').getContext('2d');
  const routes = new Chart(routeCtx, {
    type: 'bar',
    data: {
      labels: ['Autres', 'Routes 300','Routes 100'],
      datasets: [
         {
          label: 'Pickées',
          data: [0, 0, 0],
          backgroundColor: bleu,
          stack: 'Pickées',
        },
        {
          label: 'Imprimées',
          data: [0, 0, 0],
          backgroundColor: orange,
          stack: 'Imprimées',
        },
        {
          label: 'À faire',
          data: [0, 0, 0],
          backgroundColor: rouge,
          stack: 'À faire',
        }
      ]
    },
    options: {
      responsive: true,
      scales: {
        x: {
          stacked: true,
          display: true,
          title: {
            display: true,
            text: 'Catégorie de transport',
            font: {
                weight: 'bold',
              },
          }

        },
        y: {
          stacked: true,
          beginAtZero: true,
          title: {
            display: true,
            text: 'Lignes de commandes',
            font: {
                weight: 'bold',
              },
          },
             ticks: {
                // forces step size to be 50 units
                stepSize: 10
                },
                max: 200
          //type: 'logarithmic',
        }
      },
      plugins: {
        legend: {
            display: true,
            position: 'bottom'
          }
      }
    }
  });
    // Line chart for trend
  const trendCtx = document.getElementById('trend-chart').getContext('2d');
  const labels = ['05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '00', '01', '02', '03', '04']
  const trends = new Chart(trendCtx, {
    type: 'line',
    data: {
      labels: labels,
      datasets: [
         {
          label: 'Moyenne 7 jours (lignes restantes)',
          data: Array(labels.length).fill(0),
          borderColor: 'rgba(96, 125, 139, 0.5)',
          borderDash: [5, 5],
          fill: false,
          cubicInterpolationMode: 'monotone',
          tension: 0.4
        },
        //{
        //  label: "Total",
        //  data: Array(labels.length).fill(0),
        //  borderColor: 'rgba(149, 97, 226, 1)',
        //  fill: false,
        //  cubicInterpolationMode: 'monotone',
        //  tension: 0.4
        //},
        {
          label: "Restantes",
          data: Array(labels.length).fill(0),
          borderColor: mauve,
          fill: false,
          cubicInterpolationMode: 'monotone',
          tension: 0.4
        },
        {
          label: "Livrées",
          data: Array(labels.length).fill(0),
          borderColor: vert,
          fill: false,
          cubicInterpolationMode: 'monotone',
          tension: 0.4
        },
        {
          label: "Pickées",
          data: Array(labels.length).fill(0),
          borderColor: bleu,
          fill: false,
          cubicInterpolationMode: 'monotone',
          tension: 0.4
        },
        {
          label: "Imprimées",
          data: Array(labels.length).fill(0),
          borderColor: orange,
          fill: false,
          cubicInterpolationMode: 'monotone',
          tension: 0.4
        },
        {
          label: "À faire",
          data: Array(labels.length).fill(0),
          borderColor: rouge,
          fill: false,
          cubicInterpolationMode: 'monotone',
          tension: 0.4
        }
      ]
    },
    options: {
      responsive: true,
      scales: {
        y: {
          beginAtZero: true,
          title: {
            display: true,
            text: 'Lignes de commandes',
            font: {
                weight: 'bold',
              },
          },
             ticks: {
                // forces step size to be 50 units
                stepSize: 50
                }
          //type: 'logarithmic',
        },
        x:{
          display: true,
          title: {
            display: true,
            text: 'Heure du jour',
            font: {
                weight: 'bold',
              },
          }
        }
      },
      plugins: {
        legend: {
            display: true,
            position: 'bottom'
          }
      }
    }
  });
  // Function to fetch data from the API
  function fetchData() {
    // chart par types
    fetch('/api/nb_commandes_ln')
      .then(response => response.json())  // Parse JSON response
      .then(data => {
        // Update the DOM with the fetched data
        if(typeof data[0] !== 'undefined'){
            chart.data.datasets[0].data[0] = data[0].livrees;
            chart.data.datasets[0].data[1] = (data[0].total-data[0].livrees);
            chart.data.datasets[0].data[2] = data[0].completees;
            chart.data.datasets[0].data[3] = data[0].imprimees;
            chart.data.datasets[0].data[4] = data[0].afaire;
            chart.update()
            document.getElementById('comm_today').innerHTML = data[0].total;
            document.getElementById('comm_livrees').innerHTML = data[0].livrees;
            document.getElementById('comm_restant').innerHTML = (data[0].total-data[0].livrees);

            const now = new Date();
            let hour = now.getHours();
            const minutes = now.getMinutes();

            // Round to nearest hour
            if (minutes >= 30) {
            hour = (hour + 1) % 24; // Increment hour and handle 24-hour overflow
            }

            // Format the hour as a two-digit string
            const roundedHour = hour.toString().padStart(2, '0');

            // Now you can match it with the labels
            const roundedHourIndex = labels.indexOf(roundedHour);

            if (roundedHourIndex !== -1) {
            //trends.data.datasets[1].data[roundedHourIndex] = data[0].total;
            trends.data.datasets[1].data[roundedHourIndex] = data[0].total-data[0].livrees;
            trends.data.datasets[2].data[roundedHourIndex] = data[0].livrees;
            trends.data.datasets[3].data[roundedHourIndex] = data[0].completees;
            trends.data.datasets[4].data[roundedHourIndex] = data[0].imprimees;
            trends.data.datasets[5].data[roundedHourIndex] = data[0].afaire;
            trends.update()
            } 
        }
      })
    // chart par types
    fetch('/api/nb_commandes_ln_types')
      .then(response => response.json())  // Parse JSON response
      .then(data => {
        // Update the DOM with the fetched data

        let stocks = data.findIndex(item => item.type === 0);
        let cables = data.findIndex(item => item.type === 1);
        let exts = data.findIndex(item => item.type === 2);
        
        if(typeof data[stocks] !== 'undefined' && stocks !== -1){
            types.data.datasets[0].data[0] = data[stocks].completees;
            types.data.datasets[1].data[0] = data[stocks].imprimees;
            types.data.datasets[2].data[0] = data[stocks].afaire;
        }
        
        if(typeof data[cables] !== 'undefined' && cables !== -1){
            types.data.datasets[0].data[1] = data[cables].completees;
            types.data.datasets[1].data[1] = data[cables].imprimees;
            types.data.datasets[2].data[1] = data[cables].afaire;
        }

        if(typeof data[exts] !== 'undefined' && exts !== -1){
            types.data.datasets[0].data[2] = data[exts].completees;
            types.data.datasets[1].data[2] = data[exts].imprimees;
            types.data.datasets[2].data[2] = data[exts].afaire;
        }

        //types.data.datasets[0].data[2] = data.value;
        types.update()
      })
    // chart par routes
    fetch('/api/nb_commandes_ln_routes')
      .then(response => response.json())  // Parse JSON response
      .then(data => {
        // Update the DOM with the fetched data

        let autres = data.findIndex(item => item.type === 'AUTRES');
        let routes300 = data.findIndex(item => item.type === 'ROUTES 300');
        let routes100 = data.findIndex(item => item.type === 'ROUTES 100');
        
        if(typeof data[autres] !== 'undefined' && autres !== -1){
            routes.data.datasets[0].data[0] = data[autres].completees;
            routes.data.datasets[1].data[0] = data[autres].imprimees;
            routes.data.datasets[2].data[0] = data[autres].afaire;
        }

        if(typeof data[routes300] !== 'undefined' && routes300 !== -1){
            routes.data.datasets[0].data[1] = data[routes300].completees;
            routes.data.datasets[1].data[1] = data[routes300].imprimees;
            routes.data.datasets[2].data[1] = data[routes300].afaire;
        }
        
        if(typeof data[routes100] !== 'undefined' && routes300 !== -1){
            routes.data.datasets[0].data[2] = data[routes100].completees;
            routes.data.datasets[1].data[2] = data[routes100].imprimees;
            routes.data.datasets[2].data[2] = data[routes100].afaire;
        }

        //routes.data.datasets[0].data[2] = data.value;
        routes.update()
      })

    fetch('/api/nb_commandes_ln_semaine')
      .then(response => response.json())  // Parse JSON response
      .then(data => {
        const updatedData = Array(labels.length).fill(null);
        const now = new Date();
        let hour = now.getHours();
        const minutes = now.getMinutes();

        // Round to nearest hour
        if (minutes >= 30) {
        hour = (hour + 1) % 24; // Increment hour and handle 24-hour overflow
        }

        // Format the hour as a two-digit string
        const roundedHour = hour.toString().padStart(2, '0');

        // Now you can match it with the labels
        const roundedHourIndex = labels.indexOf(roundedHour);

        if (roundedHourIndex !== -1) {
        //trends.data.datasets[1].data[roundedHourIndex] = data[0].total;
        // Map the API data to the correct label index
        data.forEach(item => {
          const labelIndex = labels.indexOf(item.heure); // Find the index of the hour in the labels
          if ((labelIndex !== -1) && (labelIndex <= roundedHourIndex)) {
            updatedData[labelIndex] = (item.total - item.livrees); // Update the corresponding index with the new total
          }
        });
        trends.data.datasets[0].data = updatedData;
        trends.update()
        } 
      })
    // chart par routes
    fetch('/api/nb_commandes_ln_jour')
      .then(response => response.json())  // Parse JSON response
      .then(data => {
        // Update the DOM with the fetched data
        const total = Array(labels.length).fill(null);
        const restantes = Array(labels.length).fill(null);
        const livrees = Array(labels.length).fill(null);
        const completees = Array(labels.length).fill(null);
        const imprimees = Array(labels.length).fill(null);
        const afaire = Array(labels.length).fill(null);
        // Map the API data to the correct label index
        data.forEach(item => {
          const labelIndex = labels.indexOf(item.heure); // Find the index of the hour in the labels
          if (labelIndex !== -1) {
            total[labelIndex] = item.total; // Update the corresponding index with the new total
            restantes[labelIndex] = item.total -  item.livrees;
            livrees[labelIndex] = item.livrees;
            completees[labelIndex] = item.completees;
            imprimees[labelIndex] = item.imprimees;
            afaire[labelIndex] = item.afaire;
          }
        });
        //trends.data.datasets[1].data = total;
        trends.data.datasets[1].data = restantes;
        trends.data.datasets[2].data = livrees;
        trends.data.datasets[3].data = completees;
        trends.data.datasets[4].data = imprimees;
        trends.data.datasets[5].data = afaire;
        trends.update()
      })

  }

  // Call fetchData on page load
  fetchData();

  // Optionally, you can refresh the data periodically (e.g., every 5 seconds)
  setInterval(fetchData, 5000*60);  // 5 minutes interval
  });
</script>